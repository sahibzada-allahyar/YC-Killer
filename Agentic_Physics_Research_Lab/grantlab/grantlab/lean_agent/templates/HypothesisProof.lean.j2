/-!
This file is auto-generated by GrantLab's LeanAgent.

We encode a few basic invariants about the experimental plan/results as *closed*
theorems over `Nat` that Lean can decide computationally.

You can extend this file to import Mathlib and prove richer facts.
-/

-- We only rely on core Lean for these simple theorems.
-- If you want `norm_num` etc., import Mathlib and add lake configuration.

-- Counts taken from the Python pipeline:
def nA : Nat := {{ n_a }}
def nB : Nat := {{ n_b }}
def nTotal : Nat := {{ n_total }}

-- 1) Nonnegativity is trivial for Nat, but we still state decidable lemmas:
theorem counts_nonnegative : (0 ≤ nA) ∧ (0 ≤ nB) := by
  -- true for natural numbers
  exact And.intro (Nat.zero_le _) (Nat.zero_le _)

-- 2) Commutativity sanity-check:
theorem add_comm_instantiated : nA + nB = nB + nA := by
  simpa using Nat.add_comm nA nB

-- 3) Total equals sum of parts for these particular numerals.
--    We rely on computational reflection via `decide`.
theorem total_is_sum : nTotal = nA + nB := by
  -- This reduces to a true numeral equality for the specific values.
  decide

-- 4) Another simple inequality lemma:
theorem total_ge_each : (nA ≤ nTotal) ∧ (nB ≤ nTotal) := by
  have h : nTotal = nA + nB := total_is_sum
  constructor
  · simpa [h] using Nat.le.intro rfl
  · simpa [h, Nat.add_comm] using Nat.le.intro rfl
